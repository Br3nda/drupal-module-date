<?php
// $Id: date_repeat.module,v 1.13 2007/12/16 16:50:16 karens Exp $

/**
 * Implementation of hook_help()
 */
function date_repeat_help($section) {
  switch ($section) {
    case 'admin/help#date_repeat':
      return t("<p>date_repeat enables the creation of repeating event patterns. </p><ol>   <li>Set 'Repeat type'&nbsp; to the type of repeating pattern you wish to create</li>   <li>&nbsp;Set 'Until' date to control how many repeating events will be created. If you want the pattern to be indefinite, then leave 'Until' empty.</li>   <li>Set any other parameters for the repeat pattern</li>   <li>Set any exception dates to the pattern using the exception editor.&nbsp; Exception dates are dates where a repeat event will not be created even if it falls within the repeat sequence<br />   </li> </ol> <p> All other parameters operate as follows:<br /> </p><p>Multiple selections within the same parameter use an OR comparison for determining the pattern (ex. Monday OR Tuesday OR Wednesday).&nbsp; Choosing multiple parameters uses an AND comparison between the parameters (ex. on Monday AND in March).</p><p><br /> So, setting the days parameter to Monday, Wednesday--and the month parameter to July, August would result in this comparison logic: </p><p>Occurs on (Monday OR Wednesday) AND (July OR August)&nbsp;</p> <p>date_repeat's pattern creation was largely modeled on the iCal RRULE specification.</p>");
  }
}

/**
 * Implementation of hook_elements().
 */
function date_repeat_elements() {
  $type['date_repeat_rule'] = array(
    '#input' => TRUE,
    '#process' => array('date_repeat_rule_process' => array()),
    '#validate' => array('date_repeat_rule_validate' => array()),
  );
  return $type;
}

/**
 * Helper function for FREQ options.
 */
function FREQ_options() {
  return array(
    'NONE' => t('Never'),
    'DAILY' => t('Daily'),
    'WEEKLY' => t('Weekly'),
    'MONTHLY' => t('Monthly'),
    'YEARLY' => t('Yearly')
  );
}

/**
 * Helper function for FREQ options.
 *
 * Translated and untranslated arrays of the iCal day of week names.
 * We need the untranslated values for date_modify(), translated
 * values when displayed to user.
 */
function date_repeat_dow_day_options($translated = TRUE) {
  return array(
    'SU' => $translated ? t('Sunday') : 'Sunday',
    'MO' => $translated ? t('Monday') : 'Monday',
    'TU' => $translated ? t('Tuesday') : 'Tuesday',
    'WE' => $translated ? t('Wednesday') : 'Wednesday',
    'TH' => $translated ? t('Thursday') : 'Thursday',
    'FR' => $translated ? t('Friday') : 'Friday',
    'SA' => $translated ? t('Saturday') : 'Saturday',
  );
}

/**
 * Helper function for BYDAY options.
 */
function date_repeat_dow_count_options() {
  return array(
    '1' => t('1st'),
    '2' => t('2nd'),
    '3' => t('3rd'),
    '4' => t('4th'),
    '5' => t('5th'),
    '-1' => t('Last'),
    '-2' => t('Next to last'),
    '-3' => t('2nd from last'),
    '-4' => t('3rd from last'),
    '-5' => t('4th from last')
  );
}

/**
 * Helper function for BYDAY options.
 *
 * Creates options like -1SU and 2TU
 */
function date_repeat_dow_options() {
  $options = array();
  foreach (date_repeat_dow_day_options() as $dow_key => $dow_value) {
    foreach (date_repeat_dow_count_options() as $count_key => $count_value) {
      $options[$count_key.$dow_key] = $count_value.' '.$dow_value;
    }
  }
  return $options;
}

/**
 * Compute dates that match the requested rule, within a specified date range.
 */
function date_repeat_calc($rule, $start, $end, $exceptions) {
  include_once('./'. drupal_get_path('module', 'date_api') .'/date_api_ical.inc');

  // Get the parsed array of rule values.
  $rule = date_ical_parse_rule('RRULE:', $rule);

  // Create a date object for the start and end dates.
  $start_date = date_create($start, timezone_open('UTC'));
  $end_date = date_create($end, timezone_open('UTC'));

  // If the rule has an UNTIL, see if that is earlier than the end date.
  if ($rule['UNTIL']) {
    $until_date = date_ical_date($rule['UNTIL']);
    if (date_format($until_date, 'U') < date_format($end_date, 'U')) {
      $end_date = $until_date;
    }
  }

  // Get an integer value for the interval, if none given, '1' is implied.
  $interval = max(1, $rule['INTERVAL']);
  $count = $rule['COUNT'];

  // The start date always goes into the results.
  $days = array();
  date_repeat_add_dates($days, $start_date, $start_date, $end_date, $exceptions);

  // Find the time period to jump forward between dates.
  switch ($rule['FREQ']) {
   case 'DAILY':
     $jump = $interval .' days';
     break;
   case 'WEEKLY':
     $jump = $interval .' weeks';
     break;
   case 'MONTHLY':
     $jump = $interval .' months';
     break;
   case 'YEARLY':
     $jump = $interval .' years';
     break;
  }

  // The simple cases.
  if (!$rule['BYDAY']) {
    // $current_day will keep track of where we are in the calculation.
    $current_day = drupal_clone($start_date);

    $finished = FALSE;
    while (!$finished) {
      date_next($current_day, $jump);
      date_repeat_add_dates($days, $current_day, $start_date, $end_date, $exceptions);

      // Stop when $current_day is greater than $end_date or $count is reached.
      if (($count && sizeof($days) >= $count) ||
        date_format($current_day, 'U') > date_format($end_date, 'U')) {
        $finished = TRUE;
      }
    }
  }

  // More complex searches for day names and criteria like '-1SU' or '2TU,2TH',
  // where we interate through the whole time period checking each BYDAY.

  else {

    // Create helper array to pull day names out of iCal day strings.
    $day_names = date_repeat_dow_day_options();
    $days_of_week = array_keys($day_names);

    // Parse out information about the BYDAYs and separate them
    // depending on whether they have parameters like -1SU or 2TH.
    $month_days = array();
    $week_days = array();
    foreach ($rule['BYDAY'] as $day) {
      ereg("(-)?([1-5])?([SU|MO|TU|WE|TH|FR|SA]{2})", $day, $regs);
      if (!empty($regs[2])) {
        // Convert parameters into full day name, count, and direction.
        $month_days[] = array(
          'day' => $day_names[$regs[3]],
          'direction' => $regs[1],
          'direction_count' => $regs[2],
          );
      }
      else {
        $week_days[] = $day_names[$regs[3]];
      }
    }

    // BYDAYs with parameters like -1SU (last Sun) or 2TH (second Thur)
    // need to be processed one month at a time.
    if (!empty($month_days)) {
      $finished = FALSE;
      $current_day = drupal_clone($start_date);
      while (!$finished) {
        foreach ($month_days as $day) {
          // Find the BYDAY date in the current month.
          date_position_in_month($current_day, $day['day'], $day['direction_count'], $day['direction']);
          date_repeat_add_dates($days, $current_day, $start_date, $end_date, $exceptions);
        }
        // Stop when $current_day is greater than $end_date or $count is reached.
        if (($count && sizeof($days) >= $count) ||
          date_format($current_day, 'U') > date_format($end_date, 'U')) {
          $finished = TRUE;
        }
        // Jump to the next period.
        date_modify($current_day, '+'. $jump);
      }
    }

    // BYDAYs without parameters,like TU,TH (every Tues and Thur),
    // are are processed one week at a time.
    if (!empty($week_days)) {
      $finished = FALSE;
      $week_start_day = $rule['WKST'] ? $day_names[$rule['WKST']] : $day_names['MO'];
      $current_day = drupal_clone($start_date);
      // Move the current day back to the beginning of the week.
      date_modify($current_day, '+1 '. $week_start_day);
      date_modify($current_day, '-1 week');
      while (!$finished) {
        $next_week = drupal_clone($current_day);
        date_modify($next_week, '+1 '. $week_start_day);
        foreach ($week_days as $day) {
          // Find the next occurence of the day in this week.
          date_modify($current_day, '+1 '. $day);
          date_repeat_add_dates($days, $current_day, $start_date, $end_date, $exceptions);
        }
        // Reset the starting point to the beginning of the just processed week
        // and jump ahead by the $interval number of weeks.
        $current_day = drupal_clone($next_week);
        date_modify($current_day, '-1 weeks');
        date_modify($current_day, '+'. $jump);
        // Stop when $current_day is greater than $end_date or $count is reached.
        if (($count && sizeof($days) >= $count) ||
          date_format($current_day, 'U') > date_format($end_date, 'U')) {
          $finished = TRUE;
        }
      }
    }
  }
  sort($days);
  return $days;
}

/**
 * Helper function to add found date to the $dates array.
 *
 * Check that the date to be added is between the start and end date
 * and that it is not in the $exceptions, nor already in the $days array.
 */
function date_repeat_add_dates(&$days, $current_day, $start_date, $end_date, $exceptions) {
  $formatted = date_format($current_day, DATE_FORMAT_DATETIME);
  if ($formatted > date_format($end_date, DATE_FORMAT_DATETIME)) {
    return FALSE;
  }
  if ($formatted < date_format($start_date, DATE_FORMAT_DATETIME)) {
    return FALSE;
  }
  if (in_array($formatted, $exceptions)) {
    return FALSE;
  }
  // Don't add a day if it is already saved,
  // needed to not throw $count off.
  if (in_array($formatted, $days)) {
    return TRUE;
  }
  else {
    $days[] = $formatted;
  }
}

/**
 * Build an iCal RULE from $form_values.
 */
function date_repeat_build_rule($form_values) {

  $form_values = array_merge($form_values, $form_values['advanced'], $form_values['exceptions']);
  unset($form_values['advanced']);
  unset($form_values['exceptions']);

  //grab the RRULE data and put them into iCal RRULE format
  $RRULE = 'RRULE:FREQ='.$form_values['FREQ'];
  $RRULE .= ';INTERVAL='. $form_values['INTERVAL'];
  if ($form_values['BYDAY']) {
      $RRULE .= ';BYDAY='. implode(",", $form_values['BYDAY']);
  }
  if ($form_values['BYMONTH']) {
    $RRULE .= ';BYMONTH='. implode(",", $form_values['BYMONTH']);
  }
  if ($form_values['UNTIL']) {
    $RRULE .= ';UNTIL='. date_convert($form_values['UNTIL']['datetime'], DATE_DATETIME, DATE_ICAL);
  }
  //process the EXDATE values by looping through and recomposing them to iCal format
  if ($form_values['EXDATE']) {
    $EXDATE = array();
    foreach ($form_values['EXDATE'] as $key => $value) {
      $EXDATE[$key] = date_convert($value, DATE_DATETIME, DATE_ICAL);
    }
    $RRULE .= chr(13).chr(10).'EXDATE:'.implode(',', $EXDATE);
  }
  return $RRULE;
}

/**
 * Build a description of an iCal rule.
 */
function date_repeat_build_description($rule) {

  $rule = date_ical_parse_rule('RRULE:', $rule);
  if ($rule['FREQ'] != 'NONE') {
    $freq = FREQ_options();
    $description[] = t('!freq ', array('!freq' => $freq[$rule['FREQ']]));
  }
  if ((int) $rule['INTERVAL'] > 1) {
    switch ($rule['FREQ']) {
      case 'WEEKLY':
        $description[] = t('every !interval weeks ', array('!interval' => $rule['INTERVAL']));
        break;
      case 'MONTHLY':
        $description[] = t('every !interval months ', array('!interval' => $rule['INTERVAL']));
        break;
      case 'YEARLY':
        $description[] = t('every !interval years ', array('!interval' => $rule['INTERVAL']));
        break;
      default:
        $description[] = t('every !interval days ', array('!interval' => $rule['INTERVAL']));
        break;
    }
  }
  if ($rule['COUNT']) {
    $description[] = t('for !times occurences ', array('!times' => $rule['COUNT']));
  }
  if ($rule['UNTIL']) {
    $until = date_ical_date($rule['UNTIL']);
    $description[] = t('until !until', array('!until' => date_format($until, 'D M d Y H:i:s')));
  }
  if ($rule['BYDAY']) {
    $days = date_repeat_dow_day_options();
    $counts = date_repeat_dow_count_options();
    $results = array();
    foreach ($rule['BYDAY'] as $byday) {
      $day = substr($byday, -2);
      if ($count = intval(str_replace(' '. $day, '', $byday))) {
        $results[] = t('the !count !day ', array('!count' => $counts[$count], '!day' => $days[$day]));
      }
      else {
        $results[] = t('!day ', array('!day' => $days[$day]));
      }
    }
    $description[] = t('on !days', array('!days' => implode(t(' and '), $results)));
  }
  if ($rule['BYMONTH']) {
    $results = array();
    $months = date_calc_month_options();
    foreach ($rule['BYMONTH'] as $month) {
      $results[] = t('of !month ', array('!month' => $months[$month]));
    }
    $description[] = implode(t(' and '), $results);
  }
  if ($rule['EXDATE']) {
    $results = explode(',', $rule['EXDATE']);
    $description[] = t('except !dates ', array('!dates' => implode(', ', $results)));
  }
  if ($rule['WKST']) {
    $day_names = date_repeat_dow_day_options();
    $description[] = t('where the week starts on !start ', array('!start' => $day_names[$rule['WKST']]));
  }
  return implode('', $description);
}

/**
 * Generate the repeat setting form.
 */
function date_repeat_rule_process($element, $edit = NULL) {
  include_once('./'. drupal_get_path('module', 'date_api') .'/date_api_ical.inc');

  if (!empty($edit)) {
   $rule = date_repeat_build_rule($edit);
  }
  else {
    $rule = $element['#value'];
  }

  $form_values = (array) date_ical_parse_rule('RRULE:', $rule);

  $element['RRULE'] = array(
    '#type' => 'hidden',
    '#value' => $form_values['RRULE'],
    );
  $element['RRULE_display'] = array(
    '#value' => '<div>'. $form_values['RRULE'] .'</div>',
    );

  $exception_collapsed = ($repeat['EXDATE']) ? FALSE : TRUE;
  $collapsed = TRUE;
  if((!empty($form_values['FREQ']) != '' && $form_values['FREQ'] != 'NONE') || $exception_collapsed == FALSE){
    $collapsed = FALSE;
  }

  $element['#type'] = 'fieldset';
  $element['#title'] = t('Repeat');
  $element['#description'] = date_repeat_build_description($element['#value']['RRULE']);
  $element['#collapsible'] = TRUE;
  $element['#collapsed'] = FALSE;

  $element['FREQ'] = array(
    '#type' => 'select',
    '#title' => t('Frequency'),
    '#default_value' => !empty($form_values['FREQ']) ? $form_values['FREQ'] : 'NONE',
    '#options' => FREQ_options(),
    '#description' => t('Select \'Never\' to disable repeats for this event.')
  );

  $element['UNTIL'] = array(
    '#tree' => TRUE,
    'datetime' => array(
       '#type' => module_exists('date_popup') ? 'date_popup' : 'date_select',
        '#title' => t('Until'),
        '#description' => t('Date to stop repeating this item, leave blank for unlimited repeats.'),
        '#default_value' => !empty($form_values['UNTIL']['datetime']) ? $form_values['UNTIL']['datetime'] : '',
        '#date_timezone' => $element['#date_timezone'],
        '#date_format' => 'Y-m-d',
        '#date_type' => DATE_DATETIME,
        ),
     'tz' => array('#type' => 'hidden', '#value' => $element['#date_timezone']),
     'all_day' => array('#type' => 'hidden', '#value' => 1),
     'granularity' => array('#type' => 'hidden', '#value' => array('year', 'month', 'day')),
     );

	// start the advanced fieldset
  $element['advanced'] = array(
    '#type' => 'fieldset',
    '#title' => t('Advanced'),
    '#collapsible' => TRUE,
    '#collapsed' => $exception_collapsed,
    );

  $options = array ();
  for ($i = 1; $i <= 60; $i++) {
    $options[$i] = $i;
  }
  $element['advanced']['INTERVAL'] = array(
    '#type' => 'select',
    '#title' => t('Interval'),
    '#default_value' => (!empty($form_values['INTERVAL']) ? $form_values['INTERVAL'] : 1),
    '#options' => $options,
   '#description' => t('Frequency of repeat: 1 = every, 2 = every other, 3 = every 3rd, etc.')
  );

  $element['advanced']['BYDAY'] = array(
    '#type' => 'select',
    '#title' => t('Day(s)'),
    '#default_value' => !empty($form_values['BYDAY']) ? $form_values['BYDAY'] : '',
    '#options' => date_repeat_dow_options(),
    '#description' => t('Determines what day(s) of the week/month this event repeats on (by day of the week).  Lots of options available, scroll down!'),
    '#attributes' => array('size' => '7'),
    '#multiple' => TRUE
  );

  $element['advanced']['BYMONTH'] = array(
    '#type' => 'select',
    '#title' => t('Month(s)'),
    '#default_value' => !empty($form_values['BYMONTH']) ? $form_values['BYMONTH'] : '',
    '#options' => date_month_names(TRUE),
    '#description' => t('Selects what month(s) of the year this event repeats on'),
    '#multiple' => TRUE,
    '#size' => 5,
    );

	// start the exception fieldset
  $element['exceptions'] = array(
    '#type' => 'fieldset',
    '#title' => t('Exceptions'),
    '#collapsible' => TRUE,
    '#collapsed' => $exception_collapsed,
    );

  //if there's any exception date data, display it
  $exceptions = array();
  foreach ((array) $form_values['EXDATE'] as $value) {
    $exceptions[] = $value['datetime'];
  }
  $element['exceptions']['EXDATE'] = array(
    '#type' => 'hidden',
    '#value' => implode(', ', $exceptions),
    );
  if ($form_values['EXDATE']) {
    //parse out the individual exception dates, and put them in human-readable format
    foreach ($form_values['EXDATE'] as $key => $value) {
      $date = date_convert($value, DATE_ICAL, DATE_OBJECT);
      $date_value = date_format($date, 'Y-m-d');
      $element['exceptions']['current'][$date_value]['display'] = array(
        '#type' => 'markup',
        '#value' => '<div>'. $date_value .'</div>',
        );
      $element['exceptions']['current'][$date_value]['action'] = array(
        '#name' => 'remove_exception_'. str_replace(' ', '_', $date_value),
        '#type' => 'button',
        '#value' => 'Remove',
        );
    }
    $element['exceptions']['current'] = array(
      '#theme' => 'date_repeat_current_exceptions',
      $element['current'],
      );
  }

  //exception editor date box
  $element['exceptions']['EXCEPT'] = array(
    '#tree' => TRUE,
    'datetime' => array(
       '#type' => module_exists('date_popup') ? 'date_popup' : 'date_select',
        '#title' => t('Except'),
        '#description' => t('Enter exception dates here (dates that will not be rendered as part of the repeat sequence).  If you wish to delete an already existing exception, enter the date again. Don\'t forget to press the \'Submit\' button after editing the exception dates!'),
        '#default_value' => !empty($form_values['exceptions']['EXCEPT']['datetime']) ? $form_values['exceptions']['EXCEPT']['datetime'] : '',
        '#date_timezone' => $element['#date_timezone'],
        '#date_format' => 'Y-m-d',
        '#date_type' => DATE_DATETIME,
        ),
     'tz' => array('#type' => 'hidden', '#value' => $element['#date_timezone']),
     'all_day' => array('#type' => 'hidden', '#value' => 1),
     'granularity' => array('#type' => 'hidden', '#value' => array('year', 'month', 'day')),
     );
  $element['exceptions']['exception_button'] = array(
    '#type' => 'button',
    '#value' => t('Add Exception'),
    );
  return $element;
}

/**
 * Adds and removes exceptions from the list of current exceptions.
 */
function date_repeat_rule_validate($element){
  global $form_values;

  $field_name = $element['#parents'][0];
  $delta = $element['#parents'][1];
  $item = $form_values[$field_name][$delta]['rrule'];

  $rule = date_repeat_build_rule($item);

  $value = $item['EXCEPT'];

  // Remove exception dates that need to be deleted.
  $exceptions = array();
  foreach($item['EXDATE'] as $e){
  	$removecheck = 'remove_exception_'. str_replace(' ', '_', $e);
  	if (!$_POST[$removecheck]) {
  	  $exceptions[] = $e;
  	}
  }

  // See if a new date needs to be added.
  if(!empty($value)){
    if (!in_array($value, $exceptions)) {
      $exceptions[] = $value;
    }
  }

  // Make sure our exceptions are sorted correctly,
  // then implode them back to a string and remove the added date
  // from the date edit box.
  asort($exceptions);
  $item['EXDATE'] = implode(',', $exceptions);
  $rule = date_repeat_build_rule($item);
  form_set_value($element, $rule);
}

/**
 * Theme the exception list as a table so the buttons line up
 */
function theme_date_repeat_current_exceptions($rows = array()){
  $rows_info = array();
  foreach($rows[0] as $key => $value){
    if(is_numeric($key)){
      $rows_info[] = array(drupal_render($value['display']), drupal_render($value['action']));
    }
  }
  return theme('table', array(t('Current Exceptions'), ''), $rows_info);
}

/**
 * Themes the date repeat element.
 */
function theme_date_repeat($element) {
  //return drupal_render($element);
  //return theme('form_element', $element, '<div class="container-inline">'. drupal_render($element). '</div>');
}