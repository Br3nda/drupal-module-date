<?php
// $Id: date_repeat.module,v 1.1 2007/08/01 16:57:24 karens Exp $

function date_repeat_menu($may_cache) {
  date_load('date_calc.inc');
}

/**
 * Helper functions to handle various date formats
 */
function date_repeat_type($date) {
  if (is_numeric($date)) {
    return 'int';
  }
  elseif (stristr($date, 'T')) {
    return 'iso';
  }
  else {
    return 'datetime';
  }
}

function date_repeat_year($date) {
  switch (date_repeat_type($date)) {
    case 'int':
      return gmdate('Y', $date);
    default:
      return substr($date, 0, 4);
  }
}

function date_repeat_month($date) {
  switch (date_repeat_type($date)) {
    case 'int':
      return gmdate('m', $date);
    default:
      return intval(substr($date, 6, 2));
  }
}

function date_repeat_day($date) {
  switch (date_repeat_type($date)) {
    case 'int':
      return gmdate('j', $date);
    default:
      return intval(substr($date, 8, 2));
  }
}

/**
 * Implementation of form API hook_elements()
 */
function date_repeat_elements() {
   $type['date_repeat_date'] = array('#input' => TRUE,);
   return $type;
}

/**
 * Implementation of hook_help()
 *
 * @ingroup date_repeat_core
 * @param $section The page which is requesting help.
 * @return The help text.
 */
function date_repeat_help($section) {
  switch ($section) {
    case 'admin/help#date_repeat':
      return t("<p>date_repeat enables the creation of repeating event patterns. </p><ol>   <li>Set 'Repeat type'&nbsp; to the type of repeating pattern you wish to create</li>   <li>&nbsp;Set either 'Repeat end date' or 'Count' to determine the how many repeating events will be created (you can only set one of these parameters).&nbsp; If you want the pattern to be indefinite, then leave both of these settings empty.</li>   <li>Set any other parameters for the repeat pattern</li>   <li>Set any exception dates to the pattern using the exception editor.&nbsp; Exception dates are dates where a repeat event will not be created even if it falls within the repeat sequence<br />   </li> <li>You can't create repeat events in the past--if you set a sequence starting in the past, it will begin to render on the current date (or possibly the day before)</li> </ol> <p> Except for the Count parameter, all other parameters operate as follows:<br /> </p><p>Multiple selections within the same parameter use an OR comparison for determining the pattern (ex. Monday OR Tuesday OR Wednesday).&nbsp; Choosing multiple parameters uses an AND comparison between the parameters (ex. on Monday AND in March).</p><p><br /> So, setting the days parameter to Monday, Wednesday--and the month parameter to July, August would result in this comparison logic: </p><p>Occurs on (Monday OR Wednesday) AND (July OR August)&nbsp;</p> <p>date_repeat's pattern creation was largely modeled on the iCal RRULE specification.&nbsp; At this time, it should support all RRULE parameters, with the following exceptions:</p>  <ol>   <li>Recurrance periods less than DAILY<br />   </li>   <li>BYDAY declarations greater than 5 and less than -5 (ex. 20th Monday of the year is not supported).&nbsp; Other similar patterns can be built that should approximate this functionality.</li>   <li>BYSETPOS parameter<br />   </li> <li>EXRULE parameter<br />   </li> </ol> <p> </p><p>&nbsp;</p> <p>&nbsp;</p> <blockquote> <p> </p></blockquote>");
  }
}

/**
 * Return an array of repeat info.
 *
 * @param int $rid - an id for this rule
 * @param string $rule - the ical rule
 * @param various $repeat_start - the date to start the repeat, any date format
 * @param various $repeat_end - the date to end the repeat, any date format
 * @return array
 */
function date_repeat_get($rid, $rule, $repeat_start, $repeat_end) {
  date_load('date_ical.inc.');
  $items = date_ical_parse_rule($rule);
  return array('RID' => $rid,
               'FREQ' => $items[0]['FREQ'],
               'COUNT' => $items[0]['COUNT'],
               'INTERVAL' => $items[0]['INTERVAL'],
               'BYDAY' => $items[0]['BYDAY'],
               'BYWEEKNO' => $items[0]['BYWEEKNO'],
               'BYMONTH' => $items[0]['BYMONTH'],
               'BYMONTHDAY' => $items[0]['BYMONTHDAY'],
               'BYYEARDAY' => $items[0]['BYYEARDAY'],
               'EXDATE' => $items[0]['EXDATE'],
               'START' => $repeat_start,
               'STARTYEAR' => date_repeat_year($repeat_start),
               'STARTMONTH' => date_repeat_month($repeat_start),
               'STARTDAY' => date_repeat_day($repeat_start),
               'END' => $repeat_end, // placeholder in case the end date processing changes
               'ENDYEAR' => date_repeat_year($repeat_end),
               'ENDMONTH' => date_repeat_month($repeat_end),
               'ENDDAY' => date_repeat_day($repeat_end)
  );
}

/**
 * Generates the repeat setting form under the repeat tab, and saves repeat data to the repeat tables.
 *
 * @ingroup date_repeat_support
 * @param $repeat - the $repeat object, could be a node or field
 * @return Fully themed page containing the repeat setting form.
 */
function theme_date_repeat_form($repeat) {

  //if the node is part of a repeat sequence, then construct the radio
  //buttons for mass edit

  // TODO: review default change: moved to default of future because
  // otherwise I found that users would keep trying to change exceptions and
  // make other repeat pattern updates on occurrences by accident.
  // The "this" options is also the most destructive of the three.
  // The "future" maps a bit better to how iCal works.
  if ($repeat->RID) {
    $form['RID'] = array(
      '#type' => 'hidden',
      '#value' => $repeat->RID);
    $options = array(
      'this' => t('This occurrence only'),
      'future' => t('This occurrence and all future occurrences'),
      'all' => t('All occurrences')
    );
    $form['date_repeat_edit_type'] = array(
      '#type' => 'radios',
      '#title' => t('Apply edit(s) to'),
      '#default_value' => variable_get('date_repeat_default_edit_type', 'future'),
      '#options' => $options,
      '#description' => t('\'This occurrence and all future occurrences\' will edit repeat events from the date of the selected node forward, \'All occurrences\' will edit repeat events after today\'s date. <br>Note: editing a single occurrence will remove it from the repeat sequence.'),
      '#weight' => -12
    );
  }

  // figure out what we are expanding and create the main fieldset
  $exception_collapsed = ($repeat->EXDATE) ? FALSE : TRUE;
  $advanced_collapsed = ($repeat->INTERVAL > 1
                        || $repeat->BYDAY
                        || $repeat->BYMONTH
                        || $repeat->BYMONTHDAY
                        || $repeat->BYYEARDAY
                        || $repeat->BYWEEKNO
                       ) ? FALSE: TRUE;
  $collapsed = TRUE;
  if(($repeat->FREQ != '' && $repeat->FREQ != 'NONE')
     || $exception_collapsed == FALSE
     || $advanced_collapsed == FALSE
  ){
    $collapsed = FALSE;
  }
  $form['date_repeat'] = array(
    '#type' => 'fieldset',
    '#title' => t('Repeat'),
    '#tree' => FALSE,
    '#collapsible' => TRUE,
    '#collapsed' => $collapsed,
    '#weight' => -12,
  );

  //FREQ param select box
  $form['date_repeat']['FREQ'] = array(
    '#type' => 'select',
    '#title' => t('Repeat type'),
    '#default_value' => $repeat->FREQ ? $repeat->FREQ : 'NONE',
    '#options' => FREQ_options(),
    '#description' => t('select \'none\' to disable repeats for this event')
  );

  //put end controls in a group to make them less confusing
  $form['date_repeat']['end_controls'] = array(
    '#type' => 'fieldset',
    '#title' => t('End Settings'),
    '#collapsible' => TRUE,
    '#description' => t('Select either the end date or the number of times you want this event to repeat.')
  );

  //date box for end date
  $form['date_repeat']['end_controls']['end_date'] = array(
    '#type' => 'date_repeat_date',
    '#title' => t('Repeat end date'),
    '#process' => array('_date_repeat_form_date' => array($repeat, 'END'))
  );

  // the - or - markup
  $form['date_repeat']['end_controls']['or'] = array(
    '#type' => 'markup',
    '#value' => '<b>---' . t('OR') . '---</b>');

  // TODO: if editing based on count is unsupported, can we just use end date after the initial render?
  //COUNT param select box
  $options = array (0 => '--'. t('Select') .'--');
  for ($i = 2; $i <= 100; $i++) {
    $options[$i] = $i;
  }
  $form['date_repeat']['end_controls']['COUNT'] = array(
    '#type' => 'select',
    '#title' => t('Count'),
    '#default_value' => $repeat->COUNT ? $repeat->COUNT : 0,
    '#options' => $options,
    '#description' => t('Determines the number of repeat nodes that will be created for the repeat sequence')
  );

  $form['date_repeat'][] = theme_date_repeat_form_advanced($repeat, $advanced_collapsed);
  $form['date_repeat'][] = theme_date_repeat_form_exception($repeat, $exception_collapsed);

  return $form;
}

/**
 * theme the advanced fieldset of form elements
 */
function theme_date_repeat_form_advanced($repeat, $advanced_collapsed){

  $show_advanced = variable_get('date_repeat_showadvanced', array());
  if($show_advanced['INTERVAL'] == FALSE
    && $show_advanced['BYDAY'] == FALSE
    && $show_advanced['BYWEEKNO'] == FALSE
    && $show_advanced['BYMONTH'] == FALSE
    && $show_advanced['BYMONTHDAY'] == FALSE
    && $show_advanced['BYYEARDAY'] == FALSE
  ){
    return;
  }
  $form = array();

  // start the advanced fieldset
  $form['date_repeat_advanced'] = array(
    '#type' => 'fieldset',
    '#title' => t('Advanced'),
    '#collapsible' => TRUE,
    '#collapsed' => $advanced_collapsed,
    '#tree' => FALSE,
  );

  //link to user help for repeat patterns
  $form['date_repeat_advanced']['help'] = array(
    '#type' => 'markup',
    '#value' => '<div>'. t('Need help creating a repeat pattern? Click ') . l(t('here'), 'repeat/help') .'<br />'. t('NOTE: Editing an existing repeat pattern maps previously created events to the new pattern, in sequential order, on all dates from the date where the edit is performed.') .'</div>');

  //INTERVAL param select box
  if($show_advanced['INTERVAL']){
    $options = array ();
    for ($i = 1; $i <= 60; $i++) {
      $options[$i] = $i;
    }
    $form['date_repeat_advanced']['INTERVAL'] = array(
      '#type' => 'select',
      '#title' => t('Interval'),
      '#default_value' => ($repeat->INTERVAL) ? $repeat->INTERVAL : 1,
      '#options' => $options,
      '#description' => t('Frequency of repeat: 1 = every, 2 = every other, 3 = every 3rd, etc.')
    );
  }

  //BYDAY param select box
  if($show_advanced['BYDAY']){
    $form['date_repeat_advanced']['BYDAY'] = array(
      '#type' => 'select',
      '#title' => t('Day(s)'),
      '#default_value' => $repeat->BYDAY ? $repeat->BYDAY : '',
      '#options' => date_repeat_dow_options(),
      '#description' => t('Determines what day(s) of the week/month this event repeats on (by day of the week).  Lots of options available, scroll down!'),
      '#attributes' => array('size' => '7'),
      '#multiple' => TRUE
    );
  }


  //BYMONTH param select box
  if($show_advanced['BYMONTH']){
    $form['date_repeat_advanced']['BYMONTH'] = array(
      '#type' => 'select',
      '#title' => t('Month(s)'),
      '#default_value' => $repeat->BYMONTH ? $repeat->BYMONTH : '',
      '#options' => date_repeat_month_options(),
      '#description' => t('Selects what month(s) of the year this event repeats on'),
      '#multiple' => TRUE,
      '#size' => 5,
    );
  }

  //BYMONTHDAY param select box
  if($show_advanced['BYMONTHDAY']){
    $options = array ();
    for ($i = 1; $i <= 31; $i++) {
      $options[$i] = $i;
    }
    for ($i = -1; $i >= -31; $i--) {
      $options[$i] = $i;
    }
    $form['date_repeat_advanced']['BYMONTHDAY'] = array(
      '#type' => 'select',
      '#title' => t('Day(s) of the Month'),
      '#default_value' => $repeat->BYMONTHDAY ? $repeat->BYMONTHDAY : '',
      '#options' => $options,
      '#description' => t('Determines what day(s) of the month this event repeats on (the actual day number in the month).  Negative numbers count from the end of the month.'),
      '#multiple' => TRUE,
      '#size' => 5,
    );
  }

  //BYYEARDAY param select box
  if($show_advanced['BYYEARDAY']){
    $options = array ();
    for ($i = 1; $i <= 366; $i++) {
      $options[$i] = $i;
    }
    for ($i = -1; $i >= -366; $i--) {
      $options[$i] = $i;
    }
    $form['date_repeat_advanced']['BYYEARDAY'] = array(
      '#type' => 'select',
      '#title' => t('Day(s) of the Year'),
      '#default_value' => $repeat->BYYEARDAY ? $repeat->BYYEARDAY : '',
      '#options' => $options,
      '#description' => t('Determines what day(s) of the year this event repeats on. Negative numbers count from the end of the year.'),
      '#multiple' => TRUE,
      '#size' => 5,
    );
  }

  //BYWEEKNO param select box
  if($show_advanced['BYWEEKNO']){
    $options = array ();
    for ($i = 1; $i <= 54; $i++) {
      $options[$i] = $i;
    }
    for ($i = -1; $i >= -54; $i--) {
      $options[$i] = $i;
    }
    $form['date_repeat_advanced']['BYWEEKNO'] = array(
      '#type' => 'select',
      '#title' => t('Week Number(s)'),
      '#default_value' => $repeat->BYWEEKNO ? $repeat->BYWEEKNO : '',
      '#options' => $options,
      '#description' => t('Selects what week(s) of the year this event repeats on. Negative numbers count from the end of the year.'),
      '#multiple' => TRUE,
      '#size' => 5,
    );
  }

  return $form;

}

function FREQ_options() {
  return array(
    'NONE' => t('none'),
    'DAILY' => t('Daily'),
    'WEEKLY' => t('Weekly'),
    'MONTHLY' => t('Monthly'),
    'YEARLY' => t('Yearly')
  );
}

function date_repeat_month_options() {
  return array(
      1 => t('January'),
      2 => t('February'),
      3 => t('March'),
      4 => t('April'),
      5 => t('May'),
      6 => t('June'),
      7 => t('July'),
      8 => t('August'),
      9 => t('September'),
      10 => t('October'),
      11 => t('November'),
      12 => t('December'),
    );
}

function date_repeat_dow_day_options() {
  return array(
    'SU' => t('Sunday'),
    'MO' => t('Monday'),
    'TU' => t('Tuesday'),
    'WE' => t('Wednesday'),
    'TH' => t('Thursday'),
    'FR' => t('Friday'),
    'SA' => t('Saturday')
  );
}

function date_repeat_dow_count_options() {
  return array(
    '1' => t('1st'),
    '2' => t('2nd'),
    '3' => t('3rd'),
    '4' => t('4th'),
    '5' => t('5th'),
    '-1' => t('Last'),
    '-2' => t('Next to Last'),
    '-3' => t('2nd from Last'),
    '-4' => t('3rd from Last'),
    '-5' => t('4th from Last')
  );
}

function date_repeat_dow_options() {
  foreach (date_repeat_dow_day_options() as $DOWkey => $DOWvalue) {
    foreach (date_repeat_dow_count_options() as $Countkey => $Countvalue) {
      $options[$Countkey.$DOWkey] = $Countvalue.' '.$DOWvalue;
    }
  }
  return $options;
}
/**
 * theme the exception fieldset of form elements
 */
function theme_date_repeat_form_exception($repeat, $exception_collapsed){

	$form = array();

  // start the exception fieldset
  $form['date_repeat_exceptions'] = array(
    '#type' => 'fieldset',
    '#title' => t('Exceptions'),
    '#collapsible' => TRUE,
    '#collapsed' => $exception_collapsed,
    '#tree' => FALSE,
    );

  //if there's any exception date data, display it
  $form['date_repeat_exceptions']['EXDATE'] = array(
    '#type' => 'hidden',
    '#value' => $repeat->EXDATE);
  if ($repeat->EXDATE) {
    //calculate the hour, minute, and duration for the new node
    $starthour = (int) $repeat->event['start_orig']['hour'];
    $startminute = (int) $repeat->event['start_orig']['minute'];

    //parse out the individual exception dates, and put them in human-readable format
    $EXDATE = explode(',', $repeat->EXDATE);
    foreach ($EXDATE as $key => $value) {
      $form['date_repeat_exceptions']['current'][$value]['display'] = array(
        '#type' => 'markup',
        '#value' => '<div>'. event_format_date($value, 'custom', t('F jS, Y')).'</div>');
      $form['date_repeat_exceptions']['current'][$value]['action'] = array(
        '#name' => 'remove_exception_'. str_replace(' ', '_', $value),
        '#type' => 'button',
        '#value' => 'Remove');
    }
    $form['date_repeat_exceptions']['current'] = array(
      '#theme' => 'date_repeat_current_exceptions',
      $form['date_repeat_exceptions']['current']);
  }

  //exception editor date box
  $form['date_repeat_exceptions']['exception_editor'] = array(
    '#type' => 'date_repeat_date',
    '#title' => t('Exception Editor'),
    '#process' => array('_date_repeat_form_date' => array(NULL, 'EXDATE_edit')),
    '#description' => t('Enter exception dates here (dates that will not be rendered as part of the repeat sequence).  If you wish to delete an already existing exception, enter the date again. Don\'t forget to press the \'Submit\' button after editing the exception dates!'));
  $form['date_repeat_exceptions']['exception_button'] = array(
    '#type' => 'button',
    '#value' => t('Add Exception'));

  return $form;
}

/**
 * retheme the exception list as a table so the buttons line up
 */
function theme_date_repeat_current_exceptions($rows = array()){
  $rows_info = array();
  foreach($rows[0] as $key => $value){
    if(is_numeric($key)){
      $rows_info[] = array(drupal_render($value['display']), drupal_render($value['action']));
    }
  }

  return theme('table', array(t('Current Exceptions'), ''), $rows_info);
}

/**
 * Constructs the time select boxes.
 *
 * @ingroup date_repeat_support
 * @param $element the form element to be expanded
 * @param $repeat the node object
 * @return A form array containing a set of select boxes that contain options for month, day, year
 */
function _date_repeat_form_date($element, $edit = NULL, $repeat = NULL, $prefix = NULL) {

  //get current year, and drop next 10 years into an array
  $date = getdate(time());
  $curyear = $date['year'];
  $years = array(0 => '-'.t('Year').'-');
  $i = 0;
  while ($i < 10) {
    $years[$curyear + $i] = $curyear + $i;
    $i++;
  }

  $months = array_merge(array('-'.t('Month').'-'), date_month_names());
  $days = array_merge(array(0 => '-'.t('Day').'-'), date_days());

  //compose the select boxes, and add the exception editor button if necessary
  if(variable_get('date_repeat_dateform_order', 'euro') == 'euro'){
    $element[$prefix.'day'] = array('#type' => 'select',
      '#default_value' => $repeat->{$prefix.'day'} ? $repeat->{$prefix.'day'} : 0,
      '#options' => $days);
    $element[$prefix.'month'] = array('#type' => 'select',
      '#default_value' => $repeat->{$prefix.'month'} ? $repeat->{$prefix.'month'} : 0,
      '#options' => $months);
  }
  else {
    $element[$prefix.'month'] = array('#type' => 'select',
      '#default_value' => $repeat->{$prefix.'month'} ? $repeat->{$prefix.'month'} : 0,
      '#options' => $months);
    $element[$prefix.'day'] = array('#type' => 'select',
      '#default_value' => $repeat->{$prefix.'day'} ? $repeat->{$prefix.'day'} : 0,
      '#options' => $days);
    $element['comma'] = array('#type' => 'markup',
      '#value' => ', ');
  }
  $element[$prefix.'year'] = array('#type' => 'select',
    '#default_value' => $repeat->{$prefix.'year'} ? $repeat->{$prefix.'year'} : 0,
    '#options' => $years);

  return $element;
}

/**
 * Adds an exception to the list of current exceptions
 *
 * @param $repeat A fully loaded event node object
 */
function _date_repeat_form_add_exception(&$repeat){

  // explode our string of current exceptions
  $exceptions_temp = array();
  if(!empty($repeat->EXDATE)){
    $exceptions_temp = explode(',', $repeat->EXDATE);
  }

  // remove any that need to be deleted
  // by checking for a post button for each timestamp
  // (these are defined in theme_date_repeat_form_exception)
  $exceptions = array();
  foreach($exceptions_temp as $e){
  	$removecheck = 'remove_exception_'. str_replace(' ', '_', $e);
  	if (!$_POST[$removecheck]) {
  	  $exceptions[] = $e;
  	}
  }

  // we are only re-processing this string if we have a new exception
  // date in the dropdowns
  if($repeat->EXDATE_edityear && $repeat->EXDATE_editmonth && $repeat->EXDATE_editday){

    // validate the new exception date via the new
    // year, month and day and turn it into a timestamp
    _date_repeat_validate_form_date('EXDATE_edit', t('Exception'), $repeat);

    // only proceed if a valid date was supplied
    if($repeat->EXDATE_edit){
      // If this one does not exist in the current list, add it
      if (!in_array($repeat->EXDATE_edit, $exceptions)) {
        $exceptions[] = $repeat->EXDATE_edit;
      }

      // TODO: This does not seem to be working here,
      // and part of me likes the fact that it remembers
      // for when I am adding multiple exception dates.
      // Empty out the new exception date dropdowns.
      $repeat->EXDATE_edityear = '';
      $repeat->EXDATE_editmonth = '';
      $repeat->EXDATE_editday = '';
      $repeat->EXDATE_edit = '';
    }
  }

  // make sure our exceptions are sorted correctly,
  // then implode them back to a string
  asort($exceptions);
  $repeat->EXDATE = implode(',', $exceptions);
}


/**
 * Themes the time select boxes.
 *
 * @ingroup date_repeat_support
 * @param $element the form element to be themed
 * @return HTML string containing a set of select boxes that contain options for month, day, year
 */
function theme_date_repeat_date($element) {
  return theme('form_element', $element, '<div class="container-inline">'. $element['#children']. '</div>');
}

/**
 * helper function to turn an array of strings into a comma seperated, single quoted list.
 *
 * @param $array An array of strings.
 * @return A comma seperated, single quoted list containing the array values.
 */
function _date_repeat_stringifier($array) {
  foreach($array as $key=>$value) {
    $array[$key] = "'$value'";
  }
  return implode(',', $array);
}

/**
 * Get an iCal RULE from a $repeat object.
 */
function _date_repeat_get_rule($repeat) {
  //grab the RRULE data and put them into iCal RRULE format
  $RRULE = 'RRULE:FREQ='.$repeat->FREQ;
  if ((int) $repeat->COUNT > 1) {
    $RRULE .= ';COUNT='.$repeat->COUNT;
  }
  if ((int) $repeat->INTERVAL > 1) {
    $RRULE .= ';INTERVAL='.$repeat->INTERVAL;
  }
  if ($repeat->BYDAY) {
      $RRULE .= ';BYDAY='.implode(",", $repeat->BYDAY);
  }
  if ($repeat->BYWEEKNO) {
    $RRULE .= ';BYWEEKNO='.implode(",", $repeat->BYWEEKNO);
  }
  if ($repeat->BYMONTH) {
    $RRULE .= ';BYMONTH='.implode(",", $repeat->BYMONTH);
  }
  if ($repeat->BYMONTHDAY) {
    $RRULE .= ';BYMONTHDAY='.implode(",", $repeat->BYMONTHDAY);
  }
  if ($repeat->BYYEARDAY) {
    $RRULE .= ';BYYEARDAY='.implode(",", $repeat->BYYEARDAY);
  }

  //process the EXDATE values by looping through and recomposing them to iCal format
  if ($repeat->EXDATE) {
    $EXDATE = explode(',', $repeat->EXDATE);
    foreach ($EXDATE as $key => $value) {
      $EXDATE[$key] = gmdate("Ymd\THis\Z", $value);
    }
    $RRULE .= chr(13).chr(10).'EXDATE:'.implode(',', $EXDATE);
  }
  return $RRULE;
}

/**
 * Get an iCal RULE description from a $repeat object.
 */
function _date_repeat_get_description($repeat) {
  if ((int) $repeat->COUNT > 1) {
    $RRULE .= ';COUNT='.$repeat->COUNT;
  }
  if ((int) $repeat->INTERVAL > 1) {
    $RRULE .= ';INTERVAL='.$repeat->INTERVAL;
  }
  if ($repeat->BYDAY) {
    $days = date_repeat_dow_day_options();
    $counts = date_repeat_dow_count_options();
    $results = array();
    foreach ($repeat->BYDAY as $byday) {
      $day = substr($byday, -2);
      $count = str_replace($day, '', $byday);
      $results[] = t('the !count !day', array('!count' => $counts[$count], '!day' => $days[$day]));
    }
    $description[] = implode(t(' and '), $results);
  }
  if ($repeat->BYWEEKNO) {
    $results = array();
    foreach ($repeat->BYWEEKNO as $week) {
      $results[] = t('the !week week', array('!week' => $week));
    }
    $description[] = implode(t(' and '), $results);
  }
  if ($repeat->BYMONTH) {
    $results = array();
    $months = date_calc_month_options();
    foreach ($repeat->BYMONTH as $month) {
      $results[] = t('of !month', array('!month' => $months[$month]));
    }
    $description[] = implode(t(' and '), $results);
  }
  if ($repeat->BYMONTHDAY) {
    $results = array();
    foreach ($repeat->BYMONTHDAY as $day) {
      $results[] = t('the !day day', array('!day' => $day));
    }
    $description[] = implode(t(' and '), $results);
  }
  if ($repeat->BYYEARDAY) {
    $results = array();
    foreach ($repeat->BYYEARDAY as $day) {
      $results[] = t('the !day day of the year', array('!day' => $day));
    }
    $description[] = implode(t(' and '), $results);
  }
  if ($repeat->FREQ != 'NONE') {
    $freq = FREQ_options();
    $description[] = t('repeating !freq', array('!freq' => $freq[$repeat->FREQ]);
  }
  if ($repeat->EXDATE) {
    $results = array();
    $EXDATE = explode(',', $repeat->EXDATE);
    foreach ($EXDATE as $key => $value) {
      $results[] = gmdate("Ymd\THis\Z", $value);
    }
    $description[] = t('except !dates', array('!dates' => implode(', ', $results)));
  }
  return implode(', ', $description);
}

/**
 * Support function which renders new nodes in a repeat sequence
 *
 * @ingroup date_repeat_support
 *
 */
function date_repeat_calc($repeat, $rule, $start, $end, $exceptions) {
  //parse out the RRULE for this sequence
  date_load('date_ical.inc');
  $rule = date_ical_parse_rule($rule);
  //calculate the start time and duration for all the repeat nodes
  //we'll be creating
  $days_of_week = array('SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA');

  //if FREQ is set to WEEKLY, MONTHLY, or YEARLY, and none of the BYDAY, BYMONTHDAY, or BYYEARDAY parameters
  //are set, then this is one of the 'special case' settings
  if ($rule[0]['FREQ'] != "DAILY" && !$rule[0]['BYDAY'] &&
    !$rule[0]['BYMONTHDAY'] && !$rule[0]['BYYEARDAY']) {
    //calculate the day of the week, month, and day of the month
    //for the start date of this sequence
    $date = event_explode_date($start);
    $BYDAY = (int) gmdate('w', mktime(12, 0, 0, $date['month'], $date['day'], $date['year']));
    $BYMONTH = $date['month'];
    $BYMONTHDAY = $date['day'];
    //for weekly repeats, set the BYDAY parameter to the same day
    //of the week as the start date for this sequence
    if ($rule[0]['FREQ'] == "WEEKLY") {
      $rule[0]['BYDAY'] = array($days_of_week[$BYDAY]);
    }
    //for monthly repeats, set the BYMONTHDAY parameter to the
    //same day of the month as the start date for this sequence
    elseif ($rule[0]['FREQ'] == "MONTHLY") {
      $rule[0]['BYMONTHDAY'] = array($BYMONTHDAY);
    }
    //for yearly repeats, set the BYMONTHDAY parameter to the same
    //day of the month as the start date for this sequence, and
    //set the BYMONTH parameter to the same month as the start
    //date for this sequence
    elseif ($rule[0]['FREQ'] == "YEARLY") {
      $rule[0]['BYMONTHDAY'] = array($BYMONTHDAY);
      $rule[0]['BYMONTH'] = array($BYMONTH);
    }
  }
  if ($rule[0]['BYDAY']) {
    $BYDAY = _date_repeat_stringifier($rule[0]['BYDAY']);
  }
  if ($rule[0]['BYMONTHDAY']) {
    $BYMONTHDAY = _date_repeat_stringifier($rule[0]['BYMONTHDAY']);
  }
  if ($rule[0]['BYMONTH']) {
    $BYMONTH = _date_repeat_stringifier($rule[0]['BYMONTH']);
  }
  if ($rule[0]['BYYEARDAY']) {
    $BYYEARDAY = _date_repeat_stringifier($rule[0]['BYYEARDAY']);
  }
  if ($rule[0]['BYWEEKNO']) {
    $BYWEEKNO = _date_repeat_stringifier($rule[0]['BYWEEKNO']);
  }
  $interval = intval($rule[0]['INTERVAL']);
  if ($BYDAY) {
    $next_day = $start_date;
    while ($next_day <= $end_date) {
      $day = date_repeat_day($next_day);
      $month = date_repeat_month($next_day);
      $year = date_repeat_year($next_day);
      switch ($rule[0]['FREQ']) {
        case 'DAILY':
          if ($interval >= 0) {
            $get_date = date_calc_next_day_of_week_on_or_after($BYDAY, $day, $month, $year, '%E');
          }
          else {
            $get_date = date_calc_next_day_of_week_on_or_before($BYDAY, $day, $month, $year, '%E');
          }
          if (!in_array($get_date, $exceptions)) {
            $days[] = $get_date;
          }
          $next_day = date_calc_next_day($day, $month, $year, '%E');
          break;
        case 'WEEKLY':
          if ($interval >= 0) {
            for ($i = 1; $i <= abs($interval); $i++) {
              $get_date = date_calc_next_day_of_week_on_or_after($BYDAY, $day, $month, $year, '%E');
              $next_day = date_calc_begin_of_next_week($day, $month, $year, '%E');
              $day = date_repeat_day($next_day);
              $month = date_repeat_month($next_day);
              $year = date_repeat_year($next_day);
            }
          }
          else {
            for ($i = 1; $i <= abs($interval); $i++) {
              $get_date = date_calc_next_day_of_week_on_or_before($BYDAY, $day, $month, $year, '%E');
              $next_day = date_calc_end_of_next_week($day, $month, $year, '%E');
              $day = date_repeat_day($next_day);
              $month = date_repeat_month($next_day);
              $year = date_repeat_year($next_day);
            }
          }
          if (!in_array($get_date, $exceptions)) {
            $days[] = $get_date;
          }
          break;
        case 'MONTHLY':
          $get_date = date_calc_n_weekday_of_month($interval, $BYDAY, $month, $year, '%E');
          if (!in_array($get_date, $exceptions)) {
            $days[] = $get_date;
          }
          $next_day = date_calc_begin_of_next_month($day, $month, $year, '%E');
          break;
        case 'YEARLY':
          $get_date = date_calc_n_weekday_of_month($interval, $BYDAY, $month, $year, '%E');
          if (!in_array($get_date, $exceptions)) {
            $days[] = $get_date;
          }
          $next_day = date_calc_begin_of_next_year($day, $month, $year, '%E');
         break;
      }
    }
  }
  return $days;
}

/**
 * Validates the start and end times in a node form submission.
 *
 * @ingroup date_repeat_support
 * @param $prefix The prefix to validate and set.
 * @param $type The type of date box being validated.
 * @param $repeat The root node for the sequence being created.
 * @return Boolean indicating whether the validation was successful or not.
 */
function _date_repeat_validate_form_date($prefix, $type, &$repeat) {
  //global $form_values;
  $prefix_year = $prefix.'year';
  $prefix_month = $prefix.'month';
  $prefix_day = $prefix.'day';

  if ($repeat->$prefix_year != 0 && $repeat->$prefix_month != 0 && $repeat->$prefix_day != 0) {

    //translate the input values to the end of the day in local time.
    //we use local and not GMT time here because of the way end dates
    //are handled in the rendering code.  also here we're going to
    //validate that the end date doesn't occur on or before the start
    //date of the selected event

    if ($type != t('Exception')) {
      $event_start = $repeat->event['start'];
    }
    $repeat->$prefix = $repeat->$prefix_year .'-'. $repeat->$prefix_month .'-'. $repeat->$prefix_day .' 23:59:59';

    //if the date is after the beginning of the node in question,
    // or an exception date, then validate otherwise warn
    if (event_is_later($repeat->$prefix, $event_start) || $type == t('Exception')) {
      return TRUE;
    }
    else {
      form_set_error('ENDMONTH', t('You have selected a date that is before or the same as the start of the selected event, which is not allowed--check your repeat pattern settings and try again. <br /> Note: If you are trying to shorten the end date of a repeat cycle, perform that operation from an event date before the new end date.'));
      return FALSE;
    }
  }
  //set end date to no end
  elseif ($repeat->$prefix_year == 0 && $repeat->$prefix_month == 0 && $repeat->$prefix_day == 0) {
    $repeat->$prefix = 0;
    return TRUE;
  }
  //date data missing, so warn user
  elseif ($repeat->$prefix_month == 0) {
    form_set_error($prefix_month, t('%type date \'month\' value not selected', array('%type' => $type)));
  }
  elseif ($repeat->$prefix_day == 0) {
    form_set_error($prefix_day, t('%type date \'day\' value not selected', array('%type' => $type)));
  }
  elseif ($repeat->$prefix_year == 0) {
    form_set_error($prefix_year, t('%type date \'year\' value not selected', array('%type' => $type)));
  }
}